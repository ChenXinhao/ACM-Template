\documentclass[a4paper,openany]{book}
%\usepackage{ctex}
\usepackage{bm}
%\usepackage[fleqn]{amsmath}
\usepackage{harpoon}
\usepackage{fontspec}
\usepackage{listings}
\usepackage[left=1.5cm, right=1.5cm, top=1.5cm, bottom=1.5cm]{geometry}
\usepackage{setspace}
\usepackage{bm}
\usepackage{cmap}
\usepackage{cite}
\usepackage{float}
\usepackage{xeCJK}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{enumerate}
\usepackage{indentfirst}
\usepackage[cache=false]{minted}
\allowdisplaybreaks

%\setlength{\parindent}{0em}
%\setlength{\mathindent}{0pt}

\newfontfamily\Courier{Courier New}
\renewcommand{\theFancyVerbLine}{\rmfamily\scriptsize\arabic{FancyVerbLine}}
\newcommand{\cppcode}[1]{
    \inputminted[mathescape,
    			 tabsize=4,
    			 linenos,
    			 frame=single,
    			 framesep=2mm,
    			 breakaftergroup=true,
    			 breakautoindent=true,
    			 breakbytoken=true,
    			 breaklines=true
    ]{cpp}{#1}
}

\newcommand{\javacode}[1]{
    \inputminted[mathescape]{java}{#1}
}
\begin{document}
	\title{\textbf{\LARGE{Standard Code Library}}}
	\author{Shanghai Jiao Tong University}
	\date{October, 2015}
	\maketitle
	\tableofcontents
	\begin{spacing}{1.0}
	\chapter{数论算法}
		\section{快速数论变换}
			使用条件及注意事项：$mod$必须要是一个形如$a2^b + 1$的数，$prt$表示$mod$的原根。
			\cppcode{Source/Number-Theory/Number-Theory-Transform.cpp}
		\section{多项式求逆}
			使用条件及注意事项：求一个多项式在模意义下的逆元。
			\cppcode{Source/Number-Theory/Inverse-Polynomial.cpp}
		\section{中国剩余定理}
			使用条件及注意事项：模数可以不互质。
			\cppcode{Source/Number-Theory/Chinese-Remainder-Theorem.cpp}
		\section{Miller Rabin}
			\cppcode{Source/Number-Theory/Miller-Rabin.cpp}
		\section{Pollard Rho}
			\cppcode{Source/Number-Theory/Pollard-Rho.cpp}
		\section{坚固的逆元}
			\cppcode{Source/Number-Theory/Quick-Inverse.cpp}
		\section{直线下整点个数}
			\cppcode{Source/Number-Theory/Lattice-Count.cpp}
	\chapter{数值算法}
		\section{快速傅立叶变换}
			\cppcode{Source/Numerical-Algorithm/Fast-Fourier-Transform.cpp}
		\section{单纯形法求解线性规划}
			使用条件及注意事项：返回结果为$max\{c_{1 \times m} \cdot x_{m \times 1} \ | \ x_{m \times 1} \geq 0_{m \times 1}, a_{n \times m} \cdot x_{m \times 1} \leq b_{n \times 1}\}$
			\cppcode{Source/Numerical-Algorithm/Linear-Programming-Simplex.cpp}
		\section{自适应辛普森}
			\cppcode{Source/Numerical-Algorithm/Adaptive-Simpson.cpp}
	\chapter{数据结构}
		\section{Splay普通操作版}
			使用条件及注意事项：\par
			\begin{enumerate}
				\item 插入$x$数
				\item 删除$x$数(若有多个相同的数，因只删除一个)
				\item 查询$x$数的排名(若有多个相同的数，因输出最小的排名)
				\item 查询排名为$x$的数
				\item 求$x$的前驱(前驱定义为小于$x$，且最大的数)
				\item 求$x$的后继(后继定义为大于$x$，且最小的数)
			\end{enumerate}
			\cppcode{Source/Data-Structure/Splay-Normal.cpp}
		\section{Splay区间操作版}
			使用条件及注意事项：\par
			这是为NOI2005维修数列的代码，仅供区间操作用的splay参考。
			\cppcode{Source/Data-Structure/Splay-Interval.cpp}
		\section{坚固的Treap}
			使用条件及注意事项：题目来源UVA 12358
			\cppcode{Source/Data-Structure/Persistent-Treap}
		\section{k-d树}
			使用条件及注意事项：这是求$k$远点的代码，要求$k$近点的话把堆的比较函数改一改，把朝左儿子或者是右儿子
			的方向改一改。
			\cppcode{Source/Data-Structure/K-Dimensional-Tree.cpp}
		\section{树链剖分}
			\subsection{点操作版本}
				使用条件及注意事项：树上最大（非空）子段和，注意一条路径询问的时候信息统计的顺序。
				\cppcode{Source/Data-Structure/Heavy-Light-Decomposition-Point.cpp}
			\subsection{链操作版本}
				\cppcode{Source/Data-Structure/Heavy-Light-Decomposition-Chain.cpp}
		\section{Link-Cut-Tree}
			\cppcode{Source/Data-Structure/Link-Cut-Tree.cpp}
	\chapter{图论}
		\section{强连通分量}
			\cppcode{Source/Graph-Theory/Strongly-Connected-Components.cpp}
		\section{点双连通分量}
		\subsection{坚固的点双连通分量}
			\cppcode{Source/Graph-Theory/Super-Double-Connected-Component.cpp}
		\subsection{朴素的点双连通分量}
			\cppcode{Source/Graph-Theory/Normal-Double-Connected-Component.cpp}
		\section{2-SAT问题}
			\cppcode{Source/Graph-Theory/Two-Satisfiability.cpp}
		\section{二分图最大匹配}
			\subsection{Hungary算法}
				时间复杂度：$\mathcal{O}(V \cdot E)$
				\cppcode{Source/Graph-Theory/Maximum-Matching-Hungary.cpp}
			\subsection{Hopcroft Karp算法}
				时间复杂度：$\mathcal{O}(\sqrt{V} \cdot E)$
				\cppcode{Source/Graph-Theory/Maximum-Matching-Hopcroft-Karp.cpp}
		\section{二分图最大权匹配}
			时间复杂度：$\mathcal{O}(V^4)$
			\cppcode{Source/Graph-Theory/Maximum-Weight-Matching.cpp}
		\section{最大流}
			\subsection{Dinic}
				使用方法以及注意事项：$n$个点，$m$条边，$inf$为一个很大的值，源点$s$，汇点$t$，图中最大点的编号为$t$。\par
				\indent 邻接表：$p$数组记录节点，$nxt$数组指向下一个位置,$c$数组记录可增广量，$h$数组记录表头(初始全为-1)。\par
				\indent 时间复杂度：$\mathcal{O}(V^2 \cdot E)$
				\cppcode{Source/Graph-Theory/Maximum-Flow-Dinic.cpp}
			\subsection{ISAP}
				\indent 时间复杂度：$\mathcal{O}(V^2 \cdot E)$
				\cppcode{Source/Graph-Theory/Maximum-Flow-ISAP.cpp}
			\subsection{SAP}
				\indent 时间复杂度：$\mathcal{O}(V^2 \cdot E)$
				\cppcode{Source/Graph-Theory/Maximum-Flow-SAP.cpp}
		\section{上下界网络流}
			$B(u,v)$表示边$(u,v)$流量的下界，$C(u,v)$表示边$(u,v)$流量的上界，$F(u,v)$表示边$(u,v)$的流量。
			设$G(u,v) = F(u,v) - B(u,v)$，显然有
			$$0 \leq G(u,v) \leq C(u,v)-B(u,v)$$
		\subsection{无源汇的上下界可行流}
			建立超级源点$S^*$和超级汇点$T^*$，对于原图每条边$(u,v)$在新网络中连如下三条边：$S^* \rightarrow v$，容量为$B(u,v)$；$u \rightarrow T^*$，容量为$B(u,v)$；$u \rightarrow v$，容量为$C(u,v) - B(u,v)$。最后求新网络的最大流，判断从超级源点$S^*$出发的边是否都满流即可，边$(u,v)$的最终解中的实际流量为$G(u,v)+B(u,v)$。
		\subsection{有源汇的上下界可行流}
			从汇点$T$到源点$S$连一条上界为$\infty$，下界为$0$的边。按照\textbf{无源汇的上下界可行流}一样做即可，流量即为$T \rightarrow S$边上的流量。
		\subsection{有源汇的上下界最大流}
			\begin{enumerate}
				\item 在\textbf{有源汇的上下界可行流}中，从汇点$T$到源点$S$的边改为连一条上界为$\infty$，下届为$x$的边。$x$满足二分性质，找到最大的$x$使得新网络存在\textbf{无源汇的上下界可行流}即为原图的最大流。
				\item 从汇点$T$到源点$S$连一条上界为$\infty$，下界为$0$的边，变成无源汇的网络。按照\textbf{无源汇的上下界可行流}的方法，建立超级源点$S^*$和超级汇点$T^*$，求一遍$S^* \rightarrow T^*$的最大流，再将从汇点$T$到源点$S$的这条边拆掉，求一次$S \rightarrow T$的最大流即可。
			\end{enumerate}
		\subsection{有源汇的上下界最小流}
			\begin{enumerate}
				\item 在\textbf{有源汇的上下界可行流}中，从汇点$T$到源点$S$的边改为连一条上界为$x$，下界为$0$的边。$x$满足二分性质，找到最小的$x$使得新网络存在\textbf{无源汇的上下界可行流}即为原图的最小流。
				\item 按照\textbf{无源汇的上下界可行流}的方法，建立超级源点$S^*$与超级汇点$T^*$，求一遍$S^* \rightarrow T^*$的最大流，但是注意这一次不加上汇点$T$到源点$S$的这条边，即不使之改为无源汇的网络去求解。求完后，再加上那条汇点$T$到源点$S$上界$\infty$的边。因为这条边下界为$0$，所以$S^*$，$T^*$无影响，再直接求一次$S^* \rightarrow T^*$的最大流。若超级源点$S^*$出发的边全部满流，则$T \rightarrow S$边上的流量即为原图的最小流，否则无解。
			\end{enumerate}
		\section{最小费用最大流}
		\subsection{稀疏图}
			时间复杂度：$\mathcal{O}(V \cdot E^2)$
			\cppcode{Source/Graph-Theory/Minimum-Cost-Flow-Spfa.cpp}
		\subsection{稠密图}
			使用条件：费用非负\\
			\indent 时间复杂度：$\mathcal{O}(V \cdot E^2)$
			\cppcode{Source/Graph-Theory/Minimum-Cost-Flow-Zkw.cpp}
		\section{一般图最大匹配}
			时间复杂度：$\mathcal{O}(V^3)$
			\cppcode{Source/Graph-Theory/Maximum-Matching-Blossom.cpp}
		\section{无向图全局最小割}
			时间复杂度：$\mathcal{O}(V^3)$\\
			\indent 注意事项：处理重边时，应该对边权累加
			\cppcode{Source/Graph-Theory/Minimum-Cut-Stoer-Wagner.cpp}
		\section{最小树形图}
			\cppcode{Source/Graph-Theory/Chu-Liu-Algorithm.cpp}
		\section{有根树的同构}
			时间复杂度：$\mathcal{O}(V log V)$
			\cppcode{Source/Graph-Theory/Rooted-Tree-Isomorphism.cpp}
		\section{度限制生成树}
			\cppcode{Source/Graph-Theory/Minimum-Spanning-Tree-With-Degree-Limit.cpp}
		\section{弦图相关}
			\subsection{弦图的判定}
				\cppcode{Source/Graph-Theory/Chord-Graph-Judgement.cpp}
			\subsection{弦图的团数}
				\cppcode{Source/Graph-Theory/Chord-Graph-Group-Counter.cpp}
		\section{哈密尔顿回路（ORE性质的图）}
			ORE性质：$$\forall x,y \in V \wedge (x,y) \notin E \ \ s.t. \ \ deg_x+deg_y \geq n$$
			\indent 返回结果：从顶点$1$出发的一个哈密尔顿回路\\
			\indent 使用条件：$n \geq 3$
			\cppcode{Source/Graph-Theory/Hamiltonian-Circuit-Ore.cpp}
	\chapter{字符串}
		\section{模式串匹配}
			\cppcode{Source/String-Algorithm/Knuth-Morris-Pratt.cpp}
		\section{坚固的模式串匹配}
			\cppcode{Source/String-Algorithm/Extended-Knuth-Morris-Pratt.cpp}
		\section{AC自动机}
			\cppcode{Source/String-Algorithm/Aho-Corasick-Automaton.cpp}
		\section{后缀数组}
			\cppcode{Source/String-Algorithm/Suffix-Array.cpp}
		\section{广义后缀自动机}
			\cppcode{Source/String-Algorithm/Generalized-Suffix-Automaton.cpp}
		\section{Manacher算法}
			\cppcode{Source/String-Algorithm/Manacher.cpp}
		\section{回文树}
			\cppcode{Source/String-Algorithm/Palindromic-Tree.cpp}
		\section{循环串最小表示}
			\cppcode{Source/String-Algorithm/Minimum-Circular-Representation.cpp}
	\chapter{计算几何}
		\section{二维基础}
			\subsection{点类}
				\cppcode{Source/Computational-Geometry/Point-Class-2D.cpp}
			\subsection{凸包}
				\cppcode{Source/Computational-Geometry/Convex-Hull-2D.cpp}
			\subsection{半平面交}
				\cppcode{Source/Computational-Geometry/Half-Plane-Intersection.cpp}
			\subsection{最近点对}
				\cppcode{Source/Computational-Geometry/Closest-Pair-Of-Points.cpp}
		\section{三维基础}
			\subsection{点类}
				\cppcode{Source/Computational-Geometry/Point-Class-3D.cpp}
			\subsection{凸包}
				\cppcode{Source/Computational-Geometry/Convex-Hull-3D.cpp}
			\subsection{绕轴旋转}
				使用方法及注意事项：逆时针绕轴$AB$旋转$\theta$角
				\cppcode{Source/Computational-Geometry/Rotate-3D.cpp}
		\section{多边形}
			\subsection{判断点在多边形内部}
				\cppcode{Source/Computational-Geometry/Point-In-Polygon.cpp}
			\subsection{多边形内整点计数}
				\cppcode{Source/Computational-Geometry/Lattice-In-Polygon-Counter.cpp}
			%\subsection{旋转卡壳}
			%\subsection{动态凸包}
			%\subsection{点到凸包的切线}
			%\subsection{直线与凸包的交点}
			%\subsection{凸多边形的交集}
			%\subsection{凸多边形内的最大圆}
		\section{圆}
			%\subsubsection{圆类}
			%\subsection{圆的交集}
			\subsection{最小覆盖圆}
				\cppcode{Source/Computational-Geometry/Minimum-Coverage-Circle.cpp}
			\subsection{最小覆盖球}
				\cppcode{Source/Computational-Geometry/Minimum-Coverage-Ball.cpp}
			%\subsubsection{判断圆存在交集}
			\subsection{多边形与圆的交面积}
				\cppcode{Source/Computational-Geometry/Polygon-Circle-Intersection.cpp}
		%\subsection{三角形}
			%\subsubsection{三角形的内心}
			%\subsubsection{三角形的外心}
			%\subsubsection{三角形的垂心}
		%\subsection{黑暗科技}
			%\subsubsection{平面图形的转动惯量}
			%\subsubsection{平面区域处理}
			%\subsubsection{Vonoroi图}
	\chapter{其它}
		\section{STL使用方法}
			\input{Source/Hint/STL-Template.tex}
		\section{博弈论相关}
			\input{Source/Hint/Game-Theory.tex}
		\section{Java Reference}
			\input{Source/Hint/Java-Reference.tex}
	\chapter{数学公式}
		\input{Source/Mathematics/Mathematics-Formula.tex}
	\end{spacing}
\end{document}
